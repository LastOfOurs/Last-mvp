"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const buffer_1 = require("buffer");
global.Buffer = buffer_1.Buffer;
const url_parse_1 = __importDefault(require("url-parse"));
var TrustCommand;
(function (TrustCommand) {
    // sign a message
    TrustCommand["signMessage"] = "sign-message";
    // sign a personal message
    TrustCommand["signPersonalMessage"] = "sign-personal-message";
    // sign a transaction
    TrustCommand["signTransaction"] = "sign-transaction";
})(TrustCommand = exports.TrustCommand || (exports.TrustCommand = {}));
/**
 * @typedef {Object} Result
 * @property {string} id payload id
 * @property {string} result result value
 * @property {string} error error message
 */
(function (TrustCommand) {
    /**
     * helper method to parse url called back from Trust
     * @param urlString url called back
     * @returns {Result} parsed result
     */
    function parseURL(urlString) {
        const url = url_parse_1.default(urlString, '', true);
        const id = url.query.id || '';
        let result = url.query.result || '';
        let error = url.query.error || '0';
        result = result.replace(/ /g, '+');
        return {
            'id': id,
            'error': error,
            'result': buffer_1.Buffer.from(result, 'base64').toString('hex')
        };
    }
    TrustCommand.parseURL = parseURL;
    /**
     * generate url for Linking.openURL
     * @param data concrete command payload
     * @param scheme target wallet scheme default: trust://
     */
    function getURL(data, scheme = 'trust://') {
        var msgUrl = url_parse_1.default(scheme + data.type + '?' + data.toQuery());
        return msgUrl.toString();
    }
    TrustCommand.getURL = getURL;
})(TrustCommand = exports.TrustCommand || (exports.TrustCommand = {}));
/**
 * MessagePayload for TrustCommand.signMessage|.signPersonalMessage
 */
class MessagePayload {
    /**
     * constructor
     * @param message message to sign
     * @param address optional wallet address
     * @param callbackScheme scheme for Trust calls back
     */
    constructor(message, address, callbackScheme) {
        this.type = TrustCommand.signMessage;
        this.message = buffer_1.Buffer.from(message).toString('base64');
        this.address = address || '';
        this.callbackScheme = callbackScheme || '';
        this.id = 'msg_' + (new Date()).getTime();
    }
    toQuery() {
        var array = [];
        array.push({ k: 'message', v: this.message });
        if (this.address.length > 0) {
            array.push({ k: 'address', v: this.address });
        }
        if (this.callbackScheme.length > 0) {
            const callbackUrl = this.callbackScheme + this.type + '?id=' + this.id;
            array.push({ k: 'callback', v: callbackUrl });
        }
        return array.map((pair) => {
            return pair.k + '=' + encodeURIComponent(pair.v);
        }).join('&');
    }
}
exports.MessagePayload = MessagePayload;
/**
 * TransactionPayload for TrustCommand.signTransaction
 */
class TransactionPayload {
    /**
     * constructor
     * @param to EIP55 Address
     * @param amount Amount
     * @param data optioanl transaction data represented by hex string
     * @param gasPrice default: 21, unit: Gwei
     * @param gasLimit default: 21000
     * @param nonce default: 0
     * @param callbackScheme scheme for Trust calls back
     */
    constructor(to, amount, data, gasPrice, gasLimit, nonce, callbackScheme) {
        this.type = TrustCommand.signTransaction;
        this.to = to;
        this.amount = amount;
        this.data = data || '';
        this.gasPrice = gasPrice || '21';
        this.gasLimit = gasLimit || '21000';
        this.nonce = nonce || '0';
        this.callbackScheme = callbackScheme || '';
        this.id = 'tx_' + (new Date()).getTime();
    }
    toQuery() {
        var array = [];
        array.push({ k: 'to', v: this.to });
        array.push({ k: 'amount', v: this.amount });
        array.push({ k: 'gasPrice', v: this.gasPrice });
        array.push({ k: 'gasLimit', v: this.gasLimit });
        if (this.data.length > 0) {
            array.push({ k: 'data', v: this.data });
        }
        array.push({ k: 'nonce', v: this.nonce });
        if (this.callbackScheme.length > 0) {
            const callbackUrl = this.callbackScheme + TrustCommand.signTransaction + '?id=' + this.id;
            array.push({ k: 'callback', v: callbackUrl });
        }
        return array.map((pair) => {
            return pair.k + '=' + encodeURIComponent(pair.v);
        }).join('&');
    }
}
exports.TransactionPayload = TransactionPayload;
