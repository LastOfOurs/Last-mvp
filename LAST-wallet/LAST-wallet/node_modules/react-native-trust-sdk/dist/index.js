"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const react_native_1 = require("react-native");
const commands_1 = require("./lib/commands");
exports.TrustCommand = commands_1.TrustCommand;
exports.MessagePayload = commands_1.MessagePayload;
exports.TransactionPayload = commands_1.TransactionPayload;
var TrustError;
(function (TrustError) {
    // Unknown Error
    TrustError[TrustError["unknown"] = -1] = "unknown";
    // No Error occurred
    TrustError[TrustError["none"] = 0] = "none";
    // Error generated when the user cancells the sign request.
    TrustError[TrustError["cancelled"] = 1] = "cancelled";
    // Error generated when the request is invalid.
    TrustError[TrustError["invalidRequest"] = 2] = "invalidRequest";
    // Error generated when current wallet is watch only
    TrustError[TrustError["watchOnly"] = 3] = "watchOnly";
    // Error generated when Trust Wallet is not installed
    TrustError[TrustError["notInstalled"] = 1000] = "notInstalled";
})(TrustError = exports.TrustError || (exports.TrustError = {}));
(function (TrustError) {
    function toString(error) {
        switch (error) {
            case TrustError.unknown:
                return 'Unknown Error';
            case TrustError.none:
                return 'No Error';
            case TrustError.cancelled:
                return 'User cancelled';
            case TrustError.invalidRequest:
                return 'Signing request is invalid';
            case TrustError.watchOnly:
                return 'Wallet is watch only';
            case TrustError.notInstalled:
                return 'Trust Wallet is not installed';
            default:
                return '';
        }
    }
    TrustError.toString = toString;
})(TrustError = exports.TrustError || (exports.TrustError = {}));
class TrustWallet {
    /**
     * constructor
     * @param callbackScheme default callback scheme
     */
    constructor(callbackScheme) {
        this.app = {
            name: 'Trust',
            scheme: 'trust://',
            AppStoreURL: 'https://itunes.apple.com/us/app/trust-ethereum-wallet/id1288339409',
            GooglePlayURL: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp'
        };
        this.resolvers = {};
        this.rejectors = {};
        // Linking.getInitialURL().then((url: string) => this.handleURL(url));
        this.callbackScheme = callbackScheme;
        this.start();
    }
    /**
     * start listening openURL event, you don't need to call it unless you explicit called cleanup
     */
    start() {
        react_native_1.Linking.addEventListener('url', this.handleOpenURL.bind(this));
    }
    /**
     * stop listening openURL event and clean resolvers
     */
    cleanup() {
        react_native_1.Linking.removeEventListener('url', this.handleOpenURL.bind(this));
        this.resolvers = {};
    }
    /**
     * check if Trust Wallet is installed
     */
    installed() {
        const testUrl = this.app.scheme + commands_1.TrustCommand.signMessage; // works for iOS and Android
        return react_native_1.Linking.canOpenURL(testUrl);
    }
    /**
     * sign a transaction
     * @param payload transaction payload
     * @returns {Promise<string>} signed transaction hash
     */
    signTransaction(payload) {
        return this.runCommand(payload);
    }
    /**
     * sign a message
     * @param payload message payload
     * @returns {Promise<string>} signed message hash
     */
    signMessage(payload) {
        return this.runCommand(payload);
    }
    /**
     * sign a personal message
     * @param payload message payload
     * @returns {Promise<string>} signed personal message hash
     */
    signPersonalMessage(payload) {
        if (payload.type !== commands_1.TrustCommand.signPersonalMessage) {
            payload.type = commands_1.TrustCommand.signPersonalMessage;
        }
        return this.runCommand(payload);
    }
    runCommand(payload) {
        return this.installed()
            .then((result) => {
            return new Promise((resolve, reject) => {
                if (result) {
                    if (payload.callbackScheme.length <= 0) {
                        // set default callback scheme
                        payload.callbackScheme = this.callbackScheme;
                    }
                    // tracking resolve/reject by payload id
                    this.resolvers[payload.id] = resolve;
                    this.rejectors[payload.id] = reject;
                    const url = commands_1.TrustCommand.getURL(payload);
                    react_native_1.Linking.openURL(url);
                }
                else {
                    reject({
                        code: TrustError.notInstalled,
                        msg: TrustError.toString(TrustError.notInstalled)
                    });
                }
            });
        });
    }
    handleOpenURL(event) {
        const response = commands_1.TrustCommand.parseURL(event.url);
        const errorCode = parseInt(response.error);
        const resolver = this.resolvers[response.id];
        const rejector = this.rejectors[response.id];
        if (!resolver || !rejector) {
            return;
        }
        if (errorCode !== TrustError.none) {
            rejector({
                code: errorCode,
                msg: TrustError.toString(errorCode)
            });
        }
        else {
            resolver(response.result);
        }
        delete this.resolvers[response.id];
        delete this.rejectors[response.id];
    }
}
exports.default = TrustWallet;
